package org.pente.game;

/**
 * @author dweebo
 */
public class SimplePoofPenteState
    extends SimplePenteState {

    protected int poofedAt[][];
    protected int poofedMoves[][];

    public SimplePoofPenteState(GridState gridState) {
        super(gridState);
        init();
    }

    public SimplePoofPenteState() {
        super();
        init();
    }

    public SimplePoofPenteState(
        MoveData data,
        int boardSizeX,
        int boardSizeY) {

        super(data, boardSizeX, boardSizeY);
        init();
    }

    public SimplePoofPenteState(int boardSizeX, int boardSizeY) {
        super(boardSizeX, boardSizeY);
        init();
    }

    public void init() {
        super.init();

        poofedAt = new int[3][40];
        poofedMoves = new int[3][40];

        setTournamentRule(true);
        setGPenteRules(false);
    }

    public GridState getInstance(MoveData moveData) {


        SimpleGomokuState gomoku = new SimpleGomokuState(
        	getGridSizeX(), getGridSizeY());
        gomoku.allowOverlines(true);
        PenteState poofState = new SimplePoofPenteState(gomoku);

        poofState.setCaptureLengths(captureLengths);
        poofState.setCapturesToWin(capturesToWin);
        poofState.setGPenteRules(gPenteRules);
        poofState.setTournamentRule(tournamentRule);

        for (int i = 0; i < moveData.getNumMoves(); i++) {
        	poofState.addMove(moveData.getMove(i));
        }

        return poofState;
    }

    public void clear() {
        super.clear();

        for (int i = 0; i < poofedAt.length; i++) {
            for (int j = 0; j < poofedAt[i].length; j++) {
                poofedAt[i][j] = 0;
                poofedMoves[i][j] = 0;
            }
        }
    }

    public boolean isGameOver() {

        // check win on captures
        // must be greater than capturesToWin and greater than the opponents
        // captures.  so if the game is 10-10, play continues until one player
        // gets another capture or 5 in a row
        if (captures[1] != captures[2]) {
            if (captures[1] >= capturesToWin ||
                captures[2] >= capturesToWin) {
                return true;
            }
        }

        int lastMove = getMove(getNumMoves() - 1);
        // if the move made was captured
        if (getPosition(lastMove) == 0) {
            // since move made was poofed, we can't have won with 5 in a row
            // since the board is the same as before
            return false;
        }

        // don't call super.isGameOver() because PenteState will possibly
        // claim winning on captures when that isn't the case
        // don't really like this way of doing it, should instead have a method
        // to just check 5 in a row
        return gridState.isGameOver();
    }

    /** Overridden because it is possible for the player who just played to
     *  lose if they play into a poof which brings the capture count to 10 or
     *  above.
     */
    public int getWinner() {
        if (isGameOver()) {

            if (captures[1] > captures[2] &&
                captures[1] >= capturesToWin) {
                return 1;
            }
            else if (captures[2] > captures[1] &&
                     captures[2] >= capturesToWin) {
                return 2;
            }
            else {
                return 3 - getCurrentPlayer(); // since already updated
            }
        }
        else {
            return 0;
        }
    }

    /** Overriden to allow captures to be checked
     *  @param move The move to add to the board
     */
    public void addMove(int move) {

        gridState.addMove(move);

        for (int i = 0; i < captureLengths.length; i++) {
            makeCaptures(captureLengths[i]);
        }
        updateHash(this);
    }

    void makeCaptures(int captureLength) {

        int tempCaptured[] = new int[16]; // 16 is max?
        int numCaptured = 0;
        int tempPoofed[] = new int[8]; // 8 is max (actually 5 is but this
                                       // part of the code doesn't remove dups
        int numPoofed = 0;

        int lastPosition = getMove(getNumMoves() - 1);

        // normal capture routine except store captures temporarily
        for (int i = 0; i < surrounding.length; i++) {
            int capturedMoves[] = new int[captureLength];
            if (capture(capturedMoves, lastPosition, surrounding[i])) {
                for (int j = 0; j < captureLength; j++) {
                    tempCaptured[numCaptured++] = capturedMoves[j];
                }
            }
        }

        // go all the way around the last move and attempt to capture from that
        // position towards the last move
        for (int i = 0; i < surrounding.length; i++) {
            int newPosition = lastPosition + surrounding[i];
            if (isValidPosition(newPosition, lastPosition)) {
                int poofedMoves[] = new int[captureLength];
                if (capture(poofedMoves, newPosition, surrounding[i] * -1)) {
                    for (int j = 0; j < poofedMoves.length; j++) {
                        tempPoofed[numPoofed++] = poofedMoves[j];
                    }
                }
            }
        }

        for (int i = 0; i < numCaptured; i++) {
            captureMove(tempCaptured[i], getPosition(lastPosition));
        }
        for (int i = 0; i < numPoofed; i++) {
            poofMove(tempPoofed[i]);
        }
    }

    /** @return true if poofed ok, false if already poofed */
    protected boolean poofMove(int move) {
        int p = gridState.getCurrentPlayer();

        // make sure that don't double capture the same move
        // would occur when poof an odd number of pieces
        for (int i = 0; i < poofedAt[p].length; i++) {
            if (poofedAt[p][i] == gridState.getNumMoves() - 1 &&
                poofedMoves[p][i] == move) {
                return false;
            }
        }
        gridState.setPosition(move, 0);
        poofedAt[p][captures[p]] = gridState.getNumMoves() - 1;
        poofedMoves[p][captures[p]] = move;
        captures[p]++;

        return true;
    }

    /** Undo the last move */
    public void undoMove() {

        if (gridState.getNumMoves() == 0) {
            return;
        }

        int lastMove = gridState.getMove(gridState.getNumMoves() - 1);

        super.undoMove();

        int currentPlayer = gridState.getCurrentPlayer();
        int otherPlayer = 3 - currentPlayer;

        while (captures[otherPlayer] > 0 &&
               poofedAt[otherPlayer][captures[otherPlayer] - 1] == gridState.getNumMoves()) {

            int move = poofedMoves[otherPlayer][captures[otherPlayer] - 1];

            // if move that was poofed was the last move then set it
            // to 0
            if (move == lastMove) {
                gridState.setPosition(move, 0);
            }
            else {
                gridState.setPosition(move, gridState.getCurrentColor());
            }

            poofedAt[otherPlayer][captures[otherPlayer] - 1] = 0;
            poofedMoves[otherPlayer][captures[otherPlayer] - 1] = 0;
            captures[otherPlayer]--;
        }

        updateHash(this);
    }
    public long calcHash(long cHash, int p, int move, int rot) {

        if (p != 0) {
            cHash = super.calcHash(cHash, p, move, rot);
        }
        else {
            // moved was poofed so get the player that just moved
            // by looking at the current player
            p = 3 - getCurrentPlayer();
        }
        // if was a poof, XOR out hash for poofed pieces
        for (int i = 0; i < poofedAt[p].length; i++) {
            if (poofedAt[p][i] == 0){
                continue;
            }
            else if (poofedAt[p][i] == getNumMoves() - 1) {
                int poofMove = rotateMove(poofedMoves[p][i], rot);
                cHash ^= ZobristUtil.rand[p-1][poofMove];
            }
        }

        return cHash;
    }

//    private int getCaptureCountAt(int player, int moveNumber) {
//
//        int count = 0;
//        for (int i = 0; i < capturedAt[player].length; i++) {
//            if (capturedAt[player][i] == 0) {
//                break;
//            }
//            else if (capturedAt[player][i] > moveNumber) {
//                break;
//            }
//            else {
//                count++;
//            }
//        }
//        for (int i = 0; i < poofedAt[player].length; i++) {
//            if (poofedAt[player][i] == 0) {
//                break;
//            }
//            else if (poofedAt[player][i] > moveNumber) {
//                break;
//            }
//            else {
//                count++;
//            }
//        }
//
//        return count;
//    }
}