package org.pente.game;

/** Extension of GridState to store game states for Pente.
 * @author dweebo
 */
public class SimplePenteState extends GridStateDecorator
    implements PenteState, HashCalculator {

    /** Stores number of captures for each player */
    int         captures[];

    int         capturedAt[][];

    int         capturedMoves[][];

    boolean     tournamentRule;

    int         surrounding[];

    int         captureLengths[];

    int         capturesToWin;

    boolean     gPenteRules = false;

    boolean     dPenteRules = false;
    boolean     dPenteWaitForSwap = true;
    boolean     dPenteSwap = false;

    int x, y;//temp

    /** Create an empty pente state */
    public SimplePenteState() {
        this(19, 19);
    }

    /** Create an empty pente state wrapped around the given GridState
     *  @param gridState The base GridState to use
     */
    public SimplePenteState(GridState gridState) {
        super(gridState);

        init();
    }


    /** Create a pente state with a certain board size
     *  @param boardSize The board size
     */
    public SimplePenteState(int boardSizeX, int boardSizeY) {
        super(boardSizeX, boardSizeY);

        init();
    }

    /** Create a new pente grid state with a specified size and add the moves
     *  contained in the passed in MoveData to the board.
     *  @param data MoveData containing a list of moves
     *  @param boardSize The size of the board
     */
    public SimplePenteState(MoveData data, int boardSizeX, int boardSizeY) {
        this(boardSizeX, boardSizeY);

        init();

        for (int i = 0; i < data.getNumMoves(); i++) {
            addMove(data.getMove(i));
        }
    }

    protected void init() {
        captures = new int[3];
        capturedAt = new int[3][40];
        capturedMoves = new int[3][40];
        x = gridState.getGridSizeX();
        y = gridState.getGridSizeY();
        surrounding = new int[] {
            -1, -x - 1, -x, -x + 1,
            1, x - 1, x, x + 1 };
        captureLengths = new int[] { 2 };
        capturesToWin = 10;
    }

    public GridState getInstance(MoveData moveData) {
    	SimpleGomokuState gomoku = new SimpleGomokuState(
    		gridState.getGridSizeX(), gridState.getGridSizeY());
    	gomoku.allowOverlines(true);
        SimplePenteState state = new SimplePenteState(gomoku);

        state.setCaptureLengths(captureLengths);
        state.setCapturesToWin(capturesToWin);
        state.setGPenteRules(gPenteRules);
        state.setTournamentRule(tournamentRule);

        for (int i = 0; i < moveData.getNumMoves(); i++) {
            state.addMove(moveData.getMove(i));
        }

        return state;
    }

    public void setTournamentRule(boolean rule) {
        this.tournamentRule = rule;
    }
    public void setCaptureLengths(int lengths[]) {
        this.captureLengths = lengths;
    }

    public void setInitCaptures(int player, int caps) {
    	captures[player] = caps;
    }
    public void setCapturesToWin(int num) {
        this.capturesToWin = num;
        capturedAt = new int[3][capturesToWin * 4];
        capturedMoves = new int[3][capturesToWin * 4];
    }
    public void setGPenteRules(boolean gpente) {
        this.gPenteRules = gpente;
    }
    public void setDPenteRules(boolean dpente) {
        this.dPenteRules = dpente;
    }
    public void dPenteSwapDecisionMade(boolean swap) {
        this.dPenteWaitForSwap = false;
        this.dPenteSwap = swap;
    }
    public boolean wasDPenteSwapDecisionMade() {
        return !dPenteWaitForSwap;
    }
    public boolean didDPenteSwap() {
        return dPenteSwap;
    }

    public void clear() {
        super.clear();

        for (int i = 0; i < captures.length; i++) {
            captures[i] = 0;
        }
        for (int i = 0; i < capturedAt.length; i++) {
            for (int j = 0; j < capturedAt[i].length; j++) {
                capturedAt[i][j] = 0;
            }
        }
        for (int i = 0; i < capturedMoves.length; i++) {
            for (int j = 0; j < capturedMoves[i].length; j++) {
                capturedMoves[i][j] = 0;
            }
        }
        dPenteWaitForSwap = true;
    }

    public int getCurrentPlayer() {
        if (dPenteRules) {
            // player 1 makes 1st 4 moves
            if (getNumMoves() < 4) {
                return 1;
            }
            // it's player 2's turn while they decide to swap
            else if (getNumMoves() == 4 && dPenteWaitForSwap) {
                return 2;
            }
            else {
                return super.getCurrentPlayer();
            }
        }
        return super.getCurrentPlayer();
    }

    /** Determine if a move is valid in this grid state
     *  @param move An integer representation of a move
     *  @param player The player making the move
     */
    public boolean isValidMove(int move, int player) {

        try {
            checkOutOfBounds(move);
        } catch (IllegalArgumentException e) {
            return false;
        }

        if (player != getCurrentPlayer()) {
            return false;
        }

        if (getPosition(move) != 0) {
            return false;
        }

        // check tourney rule
        if (tournamentRule || gPenteRules) {
            if (gridState.getNumMoves() == 2 && player == 1) {
                int off = (super.getGridSizeX() / 2 - 3);
            	Coord coords = convertMove(move);
                if (coords.x > off && coords.x < (off+6) &&
                    coords.y > off && coords.y < (off+6)) {
                    return false;
                }
            }
        }

        if (gPenteRules) {
            if (gridState.getNumMoves() == 2 && player == 1) {
            	Coord coords = convertMove(move);
                if (coords.x == 9 && (coords.y == 5 || coords.y == 6 || coords.y == 12 || coords.y == 13) ||
                    coords.y == 9 && (coords.x == 5 || coords.x == 6 || coords.x == 12 || coords.x == 13)) {
                    return false;
                }
            }
        }

        // dpente has a potential swap after move 4 so we have to
        // make ALL moves invalid until the swap decision is made
        if (dPenteRules && getNumMoves() == 4 && dPenteWaitForSwap) {
            return false;
        }

        return true;
    }

    public boolean canPlayerUndo(int player) {

        // while player 1 is making the 1st 4 moves, he can request undo's
        // because he is the current player.  while player 2 is thinking about
        // swapping he can also request an undo.  once player 2 has decided
        // to swap or not, the game can not go back before move 4, just because
        // it's easier that way to handle timers etc.
        if (dPenteRules) {
            if ((gridState.getNumMoves() > 1 && gridState.getNumMoves() < 4) ||
                (gridState.getNumMoves() == 4 && dPenteWaitForSwap)) {
                return player == 1;
            }
            else if (gridState.getNumMoves() == 4 && !dPenteWaitForSwap) {
                return false;
            }
            else {
                return gridState.canPlayerUndo(player);
            }
        }
        else {
            return gridState.canPlayerUndo(player);
        }
    }

    public void checkOutOfBounds(int move) {
    	Coord p = convertMove(move);
        checkOutOfBounds(p.x, p.y);
    }
    public void checkOutOfBounds(int x, int y) {
        if (x < 0 || x >= this.x ||
            y < 0 || y >= this.y) {
            throw new IllegalArgumentException("Out of bounds");
        }
    }

    public boolean isGameOver() {

        if (gridState.isGameOver()) {
            return true;
        }

        if (captures[1] >= capturesToWin ||
            captures[2] >= capturesToWin) {
            return true;
        }

        return false;
    }

    public int getWinner() {
        if (isGameOver()) {
            return 3 - getCurrentPlayer(); // since already updated
        }
        else {
            return 0;
        }
    }

    /** Get the number of captures made by the specified player
     *  @param player The player to get the captures for
     *  @return int The number of captures, not number of captured stones
     */
    public int getNumCaptures(int player) {
        return captures[player];
    }
    public int[] getCaptures(int atMove) {
        return capturedMoves[atMove];
    }

    /** Overriden to allow captures to be checked
     *  @param move The move to add to the board
     */
    public void addMove(int move) {
        gridState.addMove(move);

        for (int i = 0; i < captureLengths.length; i++) {
            makeCaptures(captureLengths[i]);
        }
        updateHash(this);
    }

    void makeCaptures(int captureLength) {

        int lastMove = getMove(getNumMoves() - 1);
        for (int i = 0; i < surrounding.length; i++) {
            int capturedMoves[] = new int[captureLength];
            if (capture(capturedMoves, lastMove, surrounding[i])) {
                for (int j = 0; j < captureLength; j++) {
                    captureMove(capturedMoves[j], getPosition(lastMove));
                }
            }
        }
    }

    boolean capture(int capturePositions[], int startPosition, int direction) {

        int startPositionPlayer = getPosition(startPosition);
        int opponentPlayer = 3 - startPositionPlayer;

        int oldMove = startPosition;
        int newMove = oldMove;
        for (int j = 0; j < capturePositions.length + 1; j++) {

            if (!isValidPosition(newMove + direction, newMove)) {
                return false;
            }
            newMove += direction;

            // make sure in between pieces are your opponents
            if (j < capturePositions.length && getPosition(newMove) != opponentPlayer) {
                return false;
            }
            // make sure the last piece is your own piece
            else if (j == capturePositions.length && getPosition(newMove) != startPositionPlayer) {
                return false;
            }
        }

        // if we get this far we have a capture, so capture each piece
        for (int c = 0; c < capturePositions.length; c++) {
            newMove -= direction;
            capturePositions[c] = newMove;
        }

        return true;
    }




    public long calcHash(long cHash, int p, int move, int rot) {

        cHash ^= ZobristUtil.rand[p-1][rotateMove(move, rot)];

        int op = 3 - p;

        // if was a capture, XOR out hash for captured pieces
        for (int i = 0; i < capturedAt[p].length; i++) {
            if (capturedAt[p][i] == 0){
                break;
            }
            else if (capturedAt[p][i] == getNumMoves() - 1) {
                int capMove = rotateMove(capturedMoves[p][i], rot);
                cHash ^= ZobristUtil.rand[op-1][capMove];
            }
        }

        // now XOR in number captures for each player
        if (captures[1] > 0) {
            cHash ^= ZobristUtil.rand[2][captures[1]];
        }
        if (captures[2] > 0) {
            cHash ^= ZobristUtil.rand[3][captures[2]];
        }

        return cHash;
    }

    public boolean isValidPosition(int newPosition, int oldPosition) {
        int oldX = oldPosition % x;
        int newX = newPosition % x;
        int maxMove = x * y - 1;
//System.out.println("isvalid " + newPosition + "," + oldPosition);
        // if passes over side
        if ((oldX == 0 && newX == x - 1) ||
            (oldX == x - 1 && newX == 0)) {
            return false;
        }

        // if goes over top or bottom
        if (newPosition < 0 || newPosition > maxMove) {
            return false;
        }

        return true;
    }

    protected void captureMove(int move, int capturePlayer) {
        gridState.setPosition(move, 0);
        capturedAt[capturePlayer][captures[capturePlayer]] =
            gridState.getNumMoves() - 1;
        capturedMoves[capturePlayer][captures[capturePlayer]] = move;
        captures[capturePlayer]++;
    }

    /** Undo the last move */
    public void undoMove() {

        gridState.undoMove();

        int currentPlayer = getCurrentPlayer();
        int otherPlayer = 3 - currentPlayer;

        while (captures[currentPlayer] > 0 &&
               capturedAt[currentPlayer][captures[currentPlayer] - 1] == gridState.getNumMoves()) {

            int move = capturedMoves[currentPlayer][captures[currentPlayer] - 1];

            gridState.setPosition(move, otherPlayer);

            capturedAt[currentPlayer][captures[currentPlayer] - 1] = 0;
            capturedMoves[currentPlayer][captures[currentPlayer] - 1] = 0;
            captures[currentPlayer]--;
        }

        updateHash(this);
    }

//    private int getCaptureCountAt(int player, int moveNumber) {
//
//        int count = 0;
//        for (int i = 0; i < capturedAt[player].length; i++) {
//            if (capturedAt[player][i] == 0) {
//                break;
//            }
//            else if (capturedAt[player][i] > moveNumber) {
//                break;
//            }
//            else {
//                count++;
//            }
//        }
//
//        return count;
//    }

    public void printBoard() {
        ((SimpleGomokuState) gridState).printBoard();
    }
}