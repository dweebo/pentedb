package org.pente.game;

/**
 * @author dweebo
 */
public class BoatPenteState extends SimplePenteState {

	public BoatPenteState(GridState gridState) {
		super(gridState);
		setTournamentRule(true);

	}

	public BoatPenteState(int boardSizeX, int boardSizeY) {
		super(boardSizeX, boardSizeY);
		setTournamentRule(true);
	}

	public BoatPenteState(MoveData data, int boardSizeX, int boardSizeY) {
		super(data, boardSizeX, boardSizeY);
		setTournamentRule(true);
	}


	public void clear() {
		super.clear();
		winner = 0;
	}

	private static final int surrounding[] = new int[] { -1, 1, -20, 20, -19, 19, -18, 18 };
	private int winner = 0;
    public boolean isGameOver() {

    	// else check for 5 in a row that is capture proof
        int maxMove = gridState.getGridSizeX() * gridState.getGridSizeY() - 1;

        moves: for (int m = 0; m < getNumMoves(); m++) {
        	int p = m % 2 + 1;
        	int op = 3 - p;
            int moves[][] = new int[4][9];
            int c[] = new int[4];
	        cs: for (int i = 0; i < surrounding.length; i++) {

	            int newMove = getMove(m);

	            // make sure move is still there
	            if (getPosition(newMove) != p) {
	            	continue moves;
	            }
	            else if (c[i/2] == 0){
	            	moves[i/2][c[i/2]++] = newMove;
	            }

	            for (int j = 0; j < gridState.getGridSizeX(); j++) {

	                int oldX = newMove % gridState.getGridSizeX();
	                newMove += surrounding[i];
	                int newX = newMove % gridState.getGridSizeX();

	                // if passes over side
	                if ((oldX == 0 && newX == gridState.getGridSizeX() - 1) ||
	                    (oldX == gridState.getGridSizeX() - 1 && newX == 0)) {
	                    continue cs;
	                }

	                if (newMove < 0 || newMove > maxMove) {
	                    continue cs;
	                }

	                if (getPosition(newMove) != p) {
	                    continue cs;
	                }
	                moves[i/2][c[i/2]++] = newMove;
	            }
	        }

	        checkPosCaps: for (int i = 0; i < 4; i++) {
	        	if (c[i] >= 5) {

	        		// if the current move was white and black still has a win
	        		// then that means black wins (even if white makes a 5 also this turn)
	        		// otherwise continue checking all moves, if in the end
	        		// white wins with black having no counter-moves, then white wins
	        		if (p == getCurrentPlayer()) {
	        			winner = p;
	        			return true;
	        		}

	        		for (int j = 0; j < c[i]; j++) {
	        			int move = moves[i][j];
	        	        for (int k = 0; k < 8; k++) {
	        	            int c1 = moves[i][j] + surrounding[k];
	        	            int c2 = c1 + surrounding[k];
	        	            int c3 = moves[i][j] - surrounding[k];
	        	            if (!isValidPosition(c1, move)) continue;
	        	            if (!isValidPosition(c2, move)) continue;
	        	            if (!isValidPosition(c3, move)) continue;

	        	            int pos1 = getPosition(c1);
	        	            int pos2 = getPosition(c2);
	        	            int pos3 = getPosition(c3);
	        	            if ((pos1 == p && pos2 == op && pos3 == 0) ||
	        	            	(pos1 == p && pos2 == 0 && pos3 == op)) {
	        	            	System.out.println("found pot. cap");
	        	                continue checkPosCaps;
	        	            }
	        	        }
	        		}
	        		winner = p;

	        	}
	        }
        }

        if (winner != 0) {
        	return true;
        }


		// if win is captures, return true
        if (captures[1] >= capturesToWin) {
        	winner = 1;
        	return true;
        }
        else if (captures[2] >= capturesToWin) {
        	winner = 2;
        	return true;
        }

        return false;
    }

    public int getWinner() {
    	if (isGameOver()) {
    		return winner;
    	}
    	else {
    		return 0;
    	}
    }

    public GridState getInstance(MoveData moveData) {
    	SimpleGomokuState gomoku = new SimpleGomokuState(
        	gridState.getGridSizeX(), gridState.getGridSizeY());
        gomoku.allowOverlines(true);
        BoatPenteState state = new BoatPenteState(gomoku);

        for (int i = 0; i < moveData.getNumMoves(); i++) {
            state.addMove(moveData.getMove(i));
        }

        return state;
    }
}
